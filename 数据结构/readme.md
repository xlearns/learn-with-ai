# 数据结构

## 数组

- array
- 定义:数组是一种线性数据结构，它由一系列相同类型的元素组成，这些元素在内存中连续存储，并可以通过索引访问。
- 特点:
  - 元素在内存中连续存储，因此可以通过索引高效地访问任意位置的元素。
  - 数组的大小是固定的，一旦创建，大小通常不能动态调整。
- 用途：存储和访问大量数据，如整数、浮点数、字符串等。
  在算法和数据结构中作为基础组件，用于实现其他数据结构和算法。
- 思考：
  - 为什么会存在这个数据结构
  - 解决了那些痛点
    - 数组提供了快速的随机访问能力，可以通过索引直接访问元素，而无需遍历整个数组。
    - 数组的大小固定，一旦创建后，无法直接动态调整大小，这可能限制了存储容量的灵活性

## 栈

- stack
- 定义:栈是一种线性数据结构，它按照"后进先出"（LIFO，Last In First Out）的原则进行操作，只能在栈顶进行插入和删除操作。
- 特点:
  - 只能在栈顶进行元素的插入（入栈）和删除（出栈）操作。
  - 最后入栈的元素将首先被访问和删除。
- 用途：
  - 函数调用和递归实现。
  - 表达式求值和后缀表达式计算。
  - 深度优先搜索算法等。
- 思考：
  - 为什么会存在这个数据结构
  - 解决了那些痛点
    - 栈提供了一种后进先出的操作方式，可以方便地保存和恢复执行上下文。
    - 栈常用于解决具有递归结构的问题，如树的遍历和深度优先搜索。

## 堆

- heap
- 定义:堆是一种特殊的树形数据结构，它满足堆属性：对于堆中的每个节点 X，X 的父节点的值大于等于（或小于等于）其子节点的值。
- 特点:
  - 堆是一个完全二叉树，通常使用数组实现。
  - 堆可以分为最大堆（父节点值大于等于子节点值）和最小堆（父节点值小于等于子节点值）。
- 用途：
  - 堆排序算法。
  - 优先队列的实现。
  - 堆可以用于解决一些具有优先级相关问题，如求 Top K 元素等。
- 思考：
  - 为什么会存在这个数据结构
  - 解决了那些痛点 - 堆提供了一种高效地获取最大或最小元素的方式。
    堆的特性使得它在解决需要优先级管理或按照特定顺序处理元素的问题上非常有用。
    最大堆常用于实现优先队列，可以高效地找到当前最大的元素。
    最小堆常用于实现任务调度，可以快速找到具有最小优先级的任务。

## 队列

- queue
- 定义:队列是一种线性数据结构，它按照"先进先出"（FIFO，First In First Out）的原则进行操作，只能在队尾进行插入操作，在队头进行删除操作。
- 特点:
  - 只能在队尾进行元素的插入（入队）操作。
  - 只能在队头进行元素的删除（出队）操作。
- 用途：
  - 任务调度和排队系统。
  - 广度优先搜索算法等。
- 思考：
  - 为什么会存在这个数据结构
  - 解决了那些痛点
    - 队列提供了一种先进先出的操作方式，类似于现实生活中排队等待的场景。
    - 队列常用于解决需要按照顺序处理元素的问题，如任务调度、广度优先搜索等。

## 散列表

- hashmap
- 定义:散列表是一种基于哈希函数实现的数据结构，它可以高效地进行插入、删除和查找操作。
- 特点:
  - 散列表通过哈希函数将键映射到存储桶中。
  - 通过散列冲突解决策略，如链地址法或开放地址法，解决键冲突问题
- 用途：
  - 快速查找和插入数据，具有常数时间复杂度的平均情况下。
  - 缓存实现、字典数据结构等。
- 思考：
  - 为什么会存在这个数据结构
  - 解决了那些痛点
    - 散列表提供了一种高效的查找和插入操作的方式。

## 图

- graph
- 定义: 图是一种非线性数据结构，它由一组节点（顶点）和连接这些节点的边组成。图可以表示各种关系和网络结构。
- 特点:
  - 图由节点和边组成，边表示节点之间的连接关系。
  - 图可以有有向边（有方向性）和无向边（无方向性）。
- 用途：
  - 图论算法，如最短路径算法、最小生成树算法等。
  - 社交网络分析、路线规划等领域。
- 思考：
  - 为什么会存在这个数据结构
  - 解决了那些痛点
    - 图提供了一种灵活的方式来表示和处理节点之间的关系。
    - 图的算法和应用非常广泛，可用于解决许多现实世界中的问题，如社交网络分析、网络路由、推荐系统等。

## 树

- tree
- 定义:
  - 树是一种非线性数据结构，它由节点和边组成，节点之间通过边连接，形成层级关系。
- 特点:
  - 树由根节点、子节点和边组成，子节点可以有自己的子节点，形成层级结构。
  - 树的层级由根节点开始，逐层向下延伸。
- 用途：
  - 用于存储层级关系的数据，如文件系统、组织结构等。
  - 树的各种变种用于实现搜索树、平衡树、堆等。
- 思考：
  - 为什么会存在这个数据结构
  - 解决了那些痛点
    - 树提供了一种有效的方式来表示层级关系和递归结构。
    - 树的结构和算法在许多领域中有广泛应用，如数据库索引、编译器语法分析等。

## 链表

- linked list
- 定义:
  - 链表是一种线性数据结构，它由节点组成，每个节点包含数据和指向下一个节点的引用。
- 特点:
  - 链表中的节点通过指针或引用进行连接，可以按照需要动态地插入、删除节点。
  - 链表可以分为单向链表和双向链表，双向链表还可以有前向引用。
- 用途：
  - 动态存储数据，可以根据需要动态调整链表的大小。
  - 链表常用于实现其他数据结构，如队列、栈等。
- 思考：
  - 为什么会存在这个数据结构
  - 解决了那些痛点
    - 链表提供了一种灵活的方式来存储和操作数据，可以动态地调整链表的大小。
    - 链表相比于数组的优势是插入和删除操作的效率高，但访问特定位置的元素效率较低。

# 算法思想

## 分治

- 是什么：分治是一种将问题划分成更小、更易解决的子问题，然后将子问题的解合并以解决原始问题的算法思想。
- 为什么：分治能够降低问题的复杂度，通过将问题分解为多个独立的子问题进行解决，提高算法的效率和可读性。
- 怎么用：使用分治思想解决问题通常包括三个步骤：分解（将问题分解为若干个子问题），解决（递归地解决子问题），合并（将子问题的解合并为原始问题的解）。
- 使用技巧：在应用分治思想时，需要注意问题是否可以被分解为独立的子问题，以及子问题之间是否存在重叠或者依赖关系。同时，选择合适的数据结构和算法来处理子问题也是关键。

## 贪心

- 是什么：贪心算法是一种每次选择当前最优解的策略，以期望获得全局最优解的算法思想。
- 为什么：贪心算法通常简单且高效，适用于一些具有最优子结构的问题，可以在有限时间内得到较优解。
- 怎么用：使用贪心算法解决问题通常包括三个步骤：问题建模（定义问题的最优解和子问题的最优解），设计贪心策略（选择当前最优解），验证策略（证明贪心策略得到全局最优解）。
- 使用技巧：贪心算法的关键在于确定每一步的最优选择，需要考虑是否存在局部最优解不一定导致全局最优解的情况。同时，贪心算法的应用范围有限，仅适用于满足贪心选择性质的问题。

## 回溯

- 是什么：回溯算法是一种通过不断尝试和回退来搜索问题的解空间的算法思想。它尝试在解空间中搜索所有可能的解，找到满足问题条件的解。
- 为什么：回溯算法适用于问题的解空间非常大且复杂，可以通过深度优先搜索的方式逐步构建解，同时利用剪枝等策略来提高搜索效率。
- 怎么用：使用回溯算法解决问题通常包括三个步骤：做出选择（从某个状态转移至下一个状态），递归进入下一层决策树，撤销选择（回溯到上一层状态）。
- 使用技使用技巧：在应用回溯算法时，需要注意以下几点：

1. 定义问题的状态：确定问题的状态表示，即如何表示每一步的选择和当前状态。

2. 判断是否满足条件：在每一步的选择中，需要判断当前状态是否满足问题的约束条件，如果不满足则进行剪枝，提前结束该路径的搜索。

3. 设定终止条件：确定何时达到了问题的终止条件，即找到了一个满足问题条件的解，或者遍历了所有可能的选择。

4. 回溯过程：在回溯的过程中，需要记录每一步的选择，并在进入下一层决策树之前做出选择，在回退时撤销选择，以便回溯到上一层状态继续搜索。

5. 剪枝策略：通过剪枝可以减少搜索空间，提高算法的效率。根据具体问题，可以采用不同的剪枝策略，例如排序提前结束、可行性剪枝、最优性剪枝等。

## 动态规划

- 是什么：动态规划是一种通过将问题分解为子问题，并通过存储子问题的解来避免重复计算的算法思想。它通常用于求解具有重叠子问题和最优子结构的问题。
- 为什么：动态规划可以在多项式时间内求解一些原本复杂度较高的问题，通过将问题分解为多个子问题，避免了重复计算，提高了算法的效率。
- 怎么用：使用动态规划解决问题通常包括三个步骤：定义状态（确定问题的状态表示），确定状态转移方程（根据子问题之间的关系定义状态转移方程），计算最优解（按照状态转移方程逐步计算最优解）。
- 使用技巧：在应用动态规划时，可以采取以下技巧：

  - 确定最优子结构：问题的最优解应该由子问题的最优解构成，通过定义好子问题之间的关系，可以推导出状态转移方程。

  - 存储中间结果：使用数组或哈希表等数据结构来存储子问题的解，避免重复计算。

  - 确定计算顺序：通常采用自底向上的计算顺序，先计算较小规模的子问题的解，再逐步计算较大规模的子问题的解，直到得到最终的问题解。

  - 优化空间复杂度：有些情况下，可以使用滚动数组或状态压缩等技巧来减少空间复杂度。

# 技技巧

## 二分法

- 是什么：二分法是一种通过将问题空间不断二分来进行搜索的算法思想。它适用于具有单调性或有序性的问题。
- 为什么：二分法能够快速定位目标值，减少搜索范围，提高搜索效率。
- 怎么用：使用二分法解决问题通常需要确定问题的搜索范围，并通过不断将范围二分来进行搜索，直到找到目标值或确定目标值不存在。
- 使用技巧：在应用二分法时，需要注意以下几点：

  - 确定搜索范围：确定问题的搜索范围，通常是一个有序的数组或区间。

  - 确定判断条件：确定问题的判断条件，即根据中间值与目标值的大小关系来判断目标值位于左侧还是右侧。

  - 更新搜索范围：根据判断条件来更新搜索范围，将问题空间二分为两部分，并继续在合适的部分进行搜索。

  - 终止条件：确定搜索的终止条件，例如找到目标值、搜索范围为空等。

## 排序

- 是什么：排序是一种将一组数据按照特定顺序重新排列的算法思想。
- 为什么：排序可以使数据具有有序性，方便后续的查找、统计和处理操作。
- 怎么用：使用排序算法通常需要选择合适的排序算法，并将待排序的数据作为输入，经过排序算法的操作得到有序的输出。
- 使用技巧：在选择排序算法时，需要考虑以下因素：

  - 稳定性：某些场景下需要保持相等元素的原有相对顺序，因此需要选择稳定的排序算法。

  - 时间复杂度：根据数据规模和性能要求选择合适的排序算法，避免性能瓶颈。

  - 额外空间：有些排序算法需要额外的空间来存储中间结果，因此需要根据空间复杂度的要求选择合适的算法。

  - 数据特性：不同的排序算法对于数据的特性有不同的适应性，例如对于小规模数据或基本有序数据，可以选择简单的排序算法。

## 双指针

- 是什么：双指针是一种通过使用两个指针在数据结构中进行遍历、搜索或处理的算法思想。
- 为什么：双指针能够在一次遍历中完成多个指针的操作，降低时间复杂度，提高算法效率。
- 怎么用：使用双指针算法通常需要初始化两个指针，并根据问题的要求移动指针，同时根据指针的位置进行相应的操作。
- 使用技巧：在应用双指针算法时，可以考虑以下几点：

  - 确定指针的初始位置：根据问题要求确定指针的初始位置，可以是数组的开头、结尾或任意位置。

  - 移动指针的策略：根据问题的要求，确定指针的移动策略，可以是同时向前或向后移动，或者根据条件移动其中一个指针。

  - 判断终止条件：确定指针移动的终止条件，例如遍历完整个数组或指针相遇等。

  - 处理指针位置：根据指针的位置进行相应的操作，例如比较指针指向的元素、交换元素位置或记录结果等。

## 滑动窗口

- 是什么：滑动窗口是一种通过维护一个窗口在数据结构中滑动来解决子数组或子字符串问题的算法思想。
- 为什么：滑动窗口可以在一次遍历中完成子数组或子字符串的搜索、计算或判断，减少时间复杂度，提高算法效率。
- 怎么用：使用滑动窗口算法通常需要初始化窗口的起始位置和结束位置，并根据问题的要求移动窗口，同时根据窗口内的元素进行相应的操作。
- 使用技巧：在应用滑动窗口算法时，可以考虑以下几点：

  - 窗口的大小：根据问题要求确定窗口的大小，可以是固定大小、可变大小或根据条件动态调整。

  - 窗口的移动策略：确定窗口的移动策略，可以是同时向前移动窗口的起始位置和结束位置，或根据条件移动其中一个位置。

  - 判断窗口内的条件：根据窗口内的元素判断是否满足问题的条件，例如求和、计数、比较等。

  - 优化窗口大小：在某些情况下，可以通过调整窗口的大小来优化算法的性能，例如缩小窗口的大小以提前结束搜索。

## 并查集

- 是什么：并查集是一种用于处理集合合并和查询连通性的数据结构和算法。
- 为什么：并查集可以高效地合并和查询元素之间的关联关系，用于解决诸如图的连通性、元素的分组等问题。
- 怎么用：使用并查集通常需要进行初始化，并支持合并两个集合和查询元素所属集合的操作。
- 使用技巧：
  在应用并查集时，可以考虑以下几点：

  - 初始化：对于给定的元素集合，需要初始化并查集，每个元素自成一个集合。

  - 合并操作：通过合并两个元素所属的集合，将它们连接在一起，形成一个更大的集合。可以使用合并操作来实现集合的合并或分组。

  - 查找操作：用于查询某个元素所属的集合，通常是通过查找集合的代表元素来判断两个元素是否属于同一个集合。可以用查找操作来判断元素的连通性。

  - 优化技巧：为了提高并查集的效率，可以使用路径压缩和按秩合并等优化技巧。路径压缩可以将查找过程中经过的所有节点直接连接到根节点，减少后续查找的时间。按秩合并可以通过记录每个集合的高度或大小，将矮的集合合并到高的集合上，保持树的平衡性，减少合并操作的时间。

## 深度优先遍历

- 是什么：深度优先遍历（DFS）是一种通过递归或栈的方式遍历图或树的算法思想。它沿着一条路径尽可能深地访问节点，直到无法继续深入，然后回溯到前一步继续遍历其他未访问的节点。
- 为什么：深度优先遍历可以用于查找图或树中的特定节点，或者遍历图或树的所有节点。它的实现相对简单，并且适用于某些特定的问题场景。
- 怎么用：使用深度优先遍历算法，需要选择起始节点，并按照深度优先的方式递归或使用栈进行遍历。
- 使用技巧：在应用深度优先遍历时，可以考虑以下几点：

  - 递归实现：使用递归方式实现深度优先遍历时，需要定义递归的终止条件和递归的调用过程。

  - 栈实现：使用栈进行深度优先遍历时，可以通过将节点入栈和出栈的方式来模拟递归调用。

  - 标记已访问节点：在遍历过程中，需要记录已经访问过的节点，以避免重复访问和陷入死循环。

  - 选择合适的遍历顺序：根据问题的要求选择合适的遍历顺序，例如先序遍历、中序遍历或后序遍历。

## 广度优先遍历

- 是什么：广度优先遍历（BFS）是一种通过队列的方式遍历图或树的算法思想。它从起始节点开始，逐层地访问节点，先访问距离起始节点最近的节点，然后依次访问与当前节点距离为 2、3...的节点。
- 为什么：广度优先遍历可以用于查找图或树中的最短路径、最小步数等问题，也可以遍历图或树的所有节点。它的实现相对简单，并且能够保证访问顺序的准确性。
- 怎么用：使用广度优先遍历算法，需要选择起始节点，并按照广度优先的方式使用队列进行遍历。
- 使用技巧：在应用广度优先遍历时，可以考虑以下几点：

  - 队列实现：使用队列进行广度优先遍历时，可以通过将节点入队和出队的方式来依次访问节点。

  - 标记已访问节点：在遍历过程中，需要记录已经访问过的节点，以避免重复访问和陷入死循环。

  - 选择合适的遍历顺序：根据问题的要求选择合适的遍历顺序，例如按层遍历或按距离遍历。

  - 记录节点的层数或距离：在某些问题中，可能需要记录节点所在的层数或与起始节点的距离，以满足问题的要求。
